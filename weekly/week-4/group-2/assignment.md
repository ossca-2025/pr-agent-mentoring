# 4ì£¼ì°¨ ë°œí‘œë¬¸

### 1. ì½”ë“œ íë¦„ ë¬¸ì„œí™”

- **What?**
    - PR-Agentì˜ ë‚´ë¶€ êµ¬ì„± ìš”ì†Œë“¤ì´ ì–´ë–»ê²Œ ìƒí˜¸ì‘ìš©í•˜ì—¬ ìµœì¢… ì½”ë“œ ë¦¬ë·° ê²°ê³¼ë¥¼ ìƒì„±í•˜ëŠ”ì§€ë¥¼ ëª…í™•í•˜ê²Œ ë‹¨ê³„ë³„ë¡œ ë¬¸ì„œí™”í•œë‹¤.
    - ê° ê°ì²´ì˜ ì—­í• , ë©”ì„œë“œ í˜¸ì¶œ íë¦„, ë°ì´í„° ì „ë‹¬ ê²½ë¡œ ë“±ì„ í…ìŠ¤íŠ¸ ë° ì‹œê°ì  ë‹¤ì´ì–´ê·¸ë¨ìœ¼ë¡œ ì„¤ëª…í•œë‹¤.
- **Why?**
    - í˜„ì¬ PR-Agentì˜ docs ë¬¸ì„œëŠ” ìƒê°ë³´ë‹¤ ì˜ ì •ë¦¬ê°€ ë˜ì–´ìˆë‹¤. ì„¤ì¹˜ ë°©ë²•ë¶€í„° ì‚¬ìš© ë°©ë²•ê¹Œì§€ ë©”ìš° êµ¬ì²´ì ìœ¼ë¡œ ì í˜€ìˆê¸°ì— ì„¤ëª…ëŒ€ë¡œë§Œ ë”°ë¼í•´ë„ ë§‰íˆëŠ” ë¶€ë¶„ì€ ì—†ë‹¤.

      ![image.png](images/image.png)

    - ì‹¤ì œ cmd ë“±ì—ì„œ ëª…ë ¹ì–´ë¥¼ ì…ë ¥í•˜ëŠ” ë°©ë²•ì— ëŒ€í•´ì„œë„ ë§¤ìš° êµ¬ì²´ì ìœ¼ë¡œ ê·¸ë¦¼ê³¼ í•¨ê»˜ ì„¤ëª…ë˜ì–´ìˆê¸°ì— ë‹¤ë¥¸ í”„ë¡œê·¸ë¨ë“¤ì˜ ë¬¸ì„œë³´ë‹¤ ë” ìœ ì €ì¹œí™”ì ì´ë¼ê³  ìƒê°í•œë‹¤.

      ![image.png](images/image%201.png)

    - ê·¸ë ‡ê¸°ì— PR-Agentë¥¼ ë‹¨ìˆœí•˜ê²Œ ì‚¬ìš©ë§Œ í•œë‹¤ë©´ í¬ê²Œ ë¬¸ì œê°€ ì—†ì„ ê²ƒì´ë‹¤.
    - ê·¸ëŸ¬ë‚˜ ìš°ë¦¬ ì¡°ì˜ ê³µí†µëœ ì˜ê²¬ì´ ê·¸ë˜ì„œ ì´ í”„ë¡œê·¸ë¨ì´ ì–´ë–»ê²Œ êµ´ëŸ¬ê°€ëŠ”ê°€ì— ëŒ€í•œ ì˜ë¬¸ì´ì—ˆë‹¤.
    - ì´ë¥¼ íŒŒì•…í•˜ê¸° ìœ„í•´ì„œëŠ” ì§ì ‘ ì½”ë“œë¥¼ ë¶„ì„í•´ì•¼ í•˜ëŠ” ë²ˆê±°ë¡œìš´ ë°©ë²•ì´ ì§„í–‰ë˜ì•¼ í•˜ê¸°ì— ì´ë¥¼ ì„¤ëª…í•´ì£¼ê³  ì‹œê°ì ìœ¼ë¡œ íŒŒì•…í•˜ê¸° ì‰½ê²Œ í—¤ì£¼ëŠ” ê²ƒì´ ì–´ë–¤ê°€ë¼ëŠ” ì˜ê²¬ì´ ë‚˜ì™”ë‹¤.
    - PR-Agentì˜ ì „ì²´ êµ¬ì¡°ì™€ ë™ì‘ ë°©ì‹ì„ ë¹ ë¥´ê²Œ ì´í•´í•˜ê³ , ì‹ ê·œ ê¸°ì—¬ìë‚˜ ì‚¬ìš©ìê°€ ì‹œìŠ¤í…œì„ íš¨ìœ¨ì ìœ¼ë¡œ íŒŒì•…í•˜ê³  í™•ì¥í•  ìˆ˜ ìˆë„ë¡ ì§€ì›í•œë‹¤.
- **How?**
    - ê°ì²´ ê°„ í˜¸ì¶œ ê´€ê³„ ë° ë°ì´í„° íë¦„ì„ Markdown ë¬¸ì„œë¡œ ì‘ì„±
    - Mermaid ë‹¤ì´ì–´ê·¸ë¨ì„ ì‚¬ìš©í•´ ë³µì¡í•œ ë¡œì§ ì‹œê°í™”
    - í´ë˜ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨ ë° ì‹œí€€ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨ ì¶”ê°€ë¡œ ë¬¸ì„œì˜ ëª…í™•ì„± ê°•í™”

        ```mermaid
        sequenceDiagram
            participant User
            participant PRAgent
            participant Tool
            participant GitProvider
            participant AIHandler
            participant AIModel
        
            User->>PRAgent: ìš”ì²­ ì „ì†¡ (PR URL, ëª…ë ¹)
            PRAgent->>Tool: ì ì ˆí•œ ë„êµ¬ ì„ íƒ ë° ì´ˆê¸°í™”
            Tool->>GitProvider: PR ë°ì´í„° ìš”ì²­
            GitProvider->>Tool: PR ë°ì´í„° ë°˜í™˜ (íŒŒì¼, ì°¨ì´, ì„¤ëª… ë“±)
            Tool->>Tool: ë°ì´í„° ì²˜ë¦¬ ë° ì••ì¶•
            Tool->>AIHandler: í”„ë¡¬í”„íŠ¸ ì „ì†¡
            AIHandler->>AIModel: ìš”ì²­ ì „ì†¡
            AIModel->>AIHandler: ì‘ë‹µ ë°˜í™˜
            AIHandler->>Tool: ì‘ë‹µ ì „ë‹¬
            Tool->>Tool: ì‘ë‹µ ì²˜ë¦¬ ë° í¬ë§·íŒ…
            Tool->>GitProvider: ê²°ê³¼ ê²Œì‹œ
            GitProvider->>User: ê²°ê³¼ í‘œì‹œ
        ```

- **êµ¬í˜„ ê³„íš**
    - **5ì£¼ì°¨**
        - PR-Agent ì „ì²´ ì½”ë“œ ë² ì´ìŠ¤ì˜ í•µì‹¬ í´ë˜ìŠ¤ ë° ë©”ì„œë“œ ë¶„ì„
        - ì£¼ìš” ì½”ë“œ íë¦„ì„ ë‹¨ê³„ë³„ë¡œ ì •ë¦¬í•˜ê³  Markdown í˜•ì‹ìœ¼ë¡œ ë¬¸ì„œ ì´ˆì•ˆ ì‘ì„±
        - í´ë˜ìŠ¤ ë° ë©”ì„œë“œ í˜¸ì¶œ ê´€ê³„ë¥¼ Mermaid ë‹¤ì´ì–´ê·¸ë¨ ì´ˆì•ˆìœ¼ë¡œ ì‘ì„±
    - **6ì£¼ì°¨**
        - ì‘ì„±í•œ Markdown ë¬¸ì„œ ë° Mermaid ë‹¤ì´ì–´ê·¸ë¨ì˜ ë‚´ìš© ë¦¬ë·° ë° ë³´ì™„
        - í´ë˜ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨, ì‹œí€€ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨ ì¶”ê°€ ì‘ì„± ë° ê²€í† 
        - ìµœì¢… ë¬¸ì„œ PR ì œì¶œ ë° Wiki í˜ì´ì§€ ë“± ë¬¸ì„œí™” ì˜ì—­ ë°˜ì˜

### ì½”ë“œ ë¦¬íŒ©í† ë§

- **What?**
    - ì¤‘ì²© ì¡°ê±´ë¬¸, ê¸´ í•¨ìˆ˜, ë°˜ë³µ ë¡œì§ ë“±ì˜ ì½”ë“œ ë¬¸ì œë¥¼ ë¦¬íŒ©í† ë§í•˜ì—¬ ì½”ë“œ ê°€ë…ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±ì„ í–¥ìƒì‹œí‚¨ë‹¤.
- **Why?**
    - í˜„ì¬ì˜ ì½”ë“œ êµ¬ì¡°ê°€ ë³µì¡í•˜ê³  ê¹Šì–´ ì´í•´í•˜ê¸° ì–´ë µê³ , ë‹¨ì¼ í•¨ìˆ˜ ë‚´ ë¡œì§ì´ ê³¼ë„í•˜ê²Œ ë§ì•„ ìœ ì§€ë³´ìˆ˜ ë° í™•ì¥ì´ ì–´ë µë‹¤.
    - ë„ˆë¬´ ë§ì€ if/else ì¤‘ì²©

        ```python
        # pr_code_suggestions.py
        	  async def run(self):
        	      try:
        	          if not self.git_provider.get_files():
        	              get_logger().info(f"PR has no files: {self.pr_url}, skipping code suggestions")
        	              return None
        	
        	          get_logger().info('Generating code suggestions for PR...')
        	          relevant_configs = {'pr_code_suggestions': dict(get_settings().pr_code_suggestions),
        	                              'config': dict(get_settings().config)}
        	          get_logger().debug("Relevant configs", artifacts=relevant_configs)
        	
        	          # publish "Preparing suggestions..." comments
        	          if (get_settings().config.publish_output and get_settings().config.publish_output_progress and
        	                  not get_settings().config.get('is_auto_command', False)):
        	              if self.git_provider.is_supported("gfm_markdown"):
        	                  self.progress_response = self.git_provider.publish_comment(self.progress)
        	              else:
        	                  self.git_provider.publish_comment("Preparing suggestions...", is_temporary=True)
        	
        	          # # call the model to get the suggestions, and self-reflect on them
        	          # if not self.is_extended:
        	          #     data = await retry_with_fallback_models(self._prepare_prediction, model_type=ModelType.REGULAR)
        	          # else:
        	          data = await retry_with_fallback_models(self.prepare_prediction_main, model_type=ModelType.REGULAR)
        	          if not data:
        	              data = {"code_suggestions": []}
        	          self.data = data
        	
        	          # Handle the case where the PR has no suggestions
        	          if (data is None or 'code_suggestions' not in data or not data['code_suggestions']):
        	              await self.publish_no_suggestions()
        	              return
        	
        	          # publish the suggestions
        	          if get_settings().config.publish_output:
        	              # If a temporary comment was published, remove it
        	              self.git_provider.remove_initial_comment()
        	
        	              # Publish table summarized suggestions
        	              if ((not get_settings().pr_code_suggestions.commitable_code_suggestions) and
        	                      self.git_provider.is_supported("gfm_markdown")):
        	
        	                  # generate summarized suggestions
        	                  pr_body = self.generate_summarized_suggestions(data)
        	                  get_logger().debug(f"PR output", artifact=pr_body)
        	
        	                  # require self-review
        	                  if get_settings().pr_code_suggestions.demand_code_suggestions_self_review:
        	                      pr_body = await self.add_self_review_text(pr_body)
        	
        	                  # add usage guide
        	                  if (get_settings().pr_code_suggestions.enable_chat_text and get_settings().config.is_auto_command
        	                          and isinstance(self.git_provider, GithubProvider)):
        	                      pr_body += "\n\n>ğŸ’¡ Need additional feedback ? start a [PR chat](https://chromewebstore.google.com/detail/ephlnjeghhogofkifjloamocljapahnl) \n\n"
        	                  if get_settings().pr_code_suggestions.enable_help_text:
        	                      pr_body += "<hr>\n\n<details> <summary><strong>ğŸ’¡ Tool usage guide:</strong></summary><hr> \n\n"
        	                      pr_body += HelpMessage.get_improve_usage_guide()
        	                      pr_body += "\n</details>\n"
        	
        	                  # Output the relevant configurations if enabled
        	                  if get_settings().get('config', {}).get('output_relevant_configurations', False):
        	                      pr_body += show_relevant_configurations(relevant_section='pr_code_suggestions')
        	
        	                  # publish the PR comment
        	                  if get_settings().pr_code_suggestions.persistent_comment: # true by default
        	                      self.publish_persistent_comment_with_history(self.git_provider,
        	                                                                   pr_body,
        	                                                                   initial_header="## PR Code Suggestions âœ¨",
        	                                                                   update_header=True,
        	                                                                   name="suggestions",
        	                                                                   final_update_message=False,
        	                                                                   max_previous_comments=get_settings().pr_code_suggestions.max_history_len,
        	                                                                   progress_response=self.progress_response)
        	                  else:
        	                      if self.progress_response:
        	                          self.git_provider.edit_comment(self.progress_response, body=pr_body)
        	                      else:
        	                          self.git_provider.publish_comment(pr_body)
        	
        	                  # dual publishing mode
        	                  if int(get_settings().pr_code_suggestions.dual_publishing_score_threshold) > 0:
        	                      await self.dual_publishing(data)
        	              else:
        	                  await self.push_inline_code_suggestions(data)
        	                  if self.progress_response:
        	                      self.git_provider.remove_comment(self.progress_response)
        	          else:
        	              get_logger().info('Code suggestions generated for PR, but not published since publish_output is False.')
        	              pr_body = self.generate_summarized_suggestions(data)
        	              get_settings().data = {"artifact": pr_body}
        	              return
        	      except Exception as e:
        	          get_logger().error(f"Failed to generate code suggestions for PR, error: {e}",
        	                             artifact={"traceback": traceback.format_exc()})
        	          if get_settings().config.publish_output:
        	              if self.progress_response:
        	                  self.progress_response.delete()
        	              else:
        	                  try:
        	                      self.git_provider.remove_initial_comment()
        	                      self.git_provider.publish_comment(f"Failed to generate code suggestions for PR")
        	                  except Exception as e:
        	                      get_logger().exception(f"Failed to update persistent review, error: {e}")
        ```

        - í•´ë‹¹ ì½”ë“œëŠ” pr_code_suggestions.pyì˜ ì½”ë“œ ì¤‘ ì¼ë¶€ë¡œ í•´ë‹¹ ì½”ë“œë§Œì´ ì•„ë‹Œ ì „ì²´ì ì¸ ì½”ë“œê°€ ëª¨ë‘ if/else ì¤‘ì²©ì´ ë§ì€ ìƒíƒœì´ë‹¤.
        - ì¶©ë¶„íˆ í•¨ìˆ˜ì™€ í´ë˜ìŠ¤ ë“±ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŒì—ë„ ë¶ˆêµ¬í•˜ê³  ë¬´ìŠ¨ ì›ì¸ì—ì„œì¸ì§€ ê·¸ëƒ¥ ê³„ì†ëœ ifë¬¸ì„ ì¤‘ì²©ì‹œì¼œ ê°€ë…ì„±ê³¼ ì½”ë“œ ì´í•´ë„ë¥¼ ë–¨ì–´íŠ¸ë¦°ë‹¤.
    - ì—¬ëŸ¬ ì±…ì„ì´ ìˆëŠ” í•¨ìˆ˜

        ```python
        @router.post("/webhook")
        async def gitlab_webhook(background_tasks: BackgroundTasks, request: Request):
            start_time = datetime.now()
            request_json = await request.json()
            context["settings"] = copy.deepcopy(global_settings)
        
            async def inner(data: dict):
                log_context = {"server_type": "gitlab_app"}
                get_logger().debug("Received a GitLab webhook")
                if request.headers.get("X-Gitlab-Token") and secret_provider:
                    request_token = request.headers.get("X-Gitlab-Token")
                    secret = secret_provider.get_secret(request_token)
                    if not secret:
                        get_logger().warning(f"Empty secret retrieved, request_token: {request_token}")
                        return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED,
                                            content=jsonable_encoder({"message": "unauthorized"}))
                    try:
                        secret_dict = json.loads(secret)
                        gitlab_token = secret_dict["gitlab_token"]
                        log_context["token_id"] = secret_dict.get("token_name", secret_dict.get("id", "unknown"))
                        context["settings"].gitlab.personal_access_token = gitlab_token
                    except Exception as e:
                        get_logger().error(f"Failed to validate secret {request_token}: {e}")
                        return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED, content=jsonable_encoder({"message": "unauthorized"}))
                elif get_settings().get("GITLAB.SHARED_SECRET"):
                    secret = get_settings().get("GITLAB.SHARED_SECRET")
                    if not request.headers.get("X-Gitlab-Token") == secret:
                        get_logger().error("Failed to validate secret")
                        return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED, content=jsonable_encoder({"message": "unauthorized"}))
                else:
                    get_logger().error("Failed to validate secret")
                    return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED, content=jsonable_encoder({"message": "unauthorized"}))
                gitlab_token = get_settings().get("GITLAB.PERSONAL_ACCESS_TOKEN", None)
                if not gitlab_token:
                    get_logger().error("No gitlab token found")
                    return JSONResponse(status_code=status.HTTP_401_UNAUTHORIZED, content=jsonable_encoder({"message": "unauthorized"}))
        
                get_logger().info("GitLab data", artifact=data)
                sender = data.get("user", {}).get("username", "unknown")
                sender_id = data.get("user", {}).get("id", "unknown")
        
                # ignore bot users
                if is_bot_user(data):
                    return JSONResponse(status_code=status.HTTP_200_OK, content=jsonable_encoder({"message": "success"}))
        
                log_context["sender"] = sender
                if data.get('object_kind') == 'merge_request':
                    # ignore MRs based on title, labels, source and target branches
                    if not should_process_pr_logic(data):
                        return JSONResponse(status_code=status.HTTP_200_OK, content=jsonable_encoder({"message": "success"}))
                    object_attributes = data.get('object_attributes', {})
                    if object_attributes.get('action') in ['open', 'reopen']:
                        url = object_attributes.get('url')
                        get_logger().info(f"New merge request: {url}")
                        if is_draft(data):
                            get_logger().info(f"Skipping draft MR: {url}")
                            return JSONResponse(status_code=status.HTTP_200_OK, content=jsonable_encoder({"message": "success"}))
        
                        await _perform_commands_gitlab("pr_commands", PRAgent(), url, log_context, data)
        
                    # for push event triggered merge requests
                    elif object_attributes.get('action') == 'update' and object_attributes.get('oldrev'):
                        url = object_attributes.get('url')
                        get_logger().info(f"New merge request: {url}")
                        if is_draft(data):
                            get_logger().info(f"Skipping draft MR: {url}")
                            return JSONResponse(status_code=status.HTTP_200_OK, content=jsonable_encoder({"message": "success"}))
        
                        commands_on_push = get_settings().get(f"gitlab.push_commands", {})
                        handle_push_trigger = get_settings().get(f"gitlab.handle_push_trigger", False)
                        if not commands_on_push or not handle_push_trigger:
                            get_logger().info("Push event, but no push commands found or push trigger is disabled")
                            return JSONResponse(status_code=status.HTTP_200_OK,
                                                content=jsonable_encoder({"message": "success"}))
        
                        get_logger().debug(f'A push event has been received: {url}')
                        await _perform_commands_gitlab("push_commands", PRAgent(), url, log_context, data)
        
                    # for draft to ready triggered merge requests
                    elif object_attributes.get('action') == 'update' and is_draft_ready(data):
                        url = object_attributes.get('url')
                        get_logger().info(f"Draft MR is ready: {url}")
        
                        # same as open MR
                        await _perform_commands_gitlab("pr_commands", PRAgent(), url, log_context, data)
        
                elif data.get('object_kind') == 'note' and data.get('event_type') == 'note': # comment on MR
                    if 'merge_request' in data:
                        mr = data['merge_request']
                        url = mr.get('url')
        
                        get_logger().info(f"A comment has been added to a merge request: {url}")
                        body = data.get('object_attributes', {}).get('note')
                        if data.get('object_attributes', {}).get('type') == 'DiffNote' and '/ask' in body: # /ask_line
                            body = handle_ask_line(body, data)
        
                        await handle_request(url, body, log_context, sender_id)
        
            background_tasks.add_task(inner, request_json)
            end_time = datetime.now()
            get_logger().info(f"Processing time: {end_time - start_time}", request=request_json)
            return JSONResponse(status_code=status.HTTP_200_OK, content=jsonable_encoder({"message": "success"}))
        ```

        - í•´ë‹¹ ì½”ë“œëŠ” servers/gitlab_webhook.pyì˜ ì½”ë“œ ì¤‘ ì¼ë¶€ì´ë‹¤.
        - í•´ë‹¹ ì½”ë“œì˜ ë¬¸ì œëŠ” í•˜ë‚˜ì˜ í•¨ìˆ˜ê°€ ë‹¨ì¼ ì±…ì„ ì›ì¹™ì„ ìœ„ë°˜ í–ˆë‹¤ëŠ” ê²ƒì´ë‹¤.
            - GitLab Webhook ìš”ì²­ ìˆ˜ì‹  ë° JSON íŒŒì‹±
            - ë³´ì•ˆ í† í° ê²€ì¦ (ë‘ ê°€ì§€ ë°©ì‹ìœ¼ë¡œ)
            - GitLab í† í° ì„¤ì • ì²˜ë¦¬
            - Webhook ì´ë²¤íŠ¸ ìœ í˜• ë¶„ê¸° ë° ì²˜ë¦¬ (Merge Request, Push, Note ë“±)
            - ê° ì´ë²¤íŠ¸ ë³„ ëª…ë ¹ ì‹¤í–‰ (`_perform_commands_gitlab`)
            - ì‘ë‹µ ì²˜ë¦¬ ë° ë¡œê¹…
        - ì´ ë˜í•œ ê°€ë…ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„± ëª¨ë‘ ë¬¸ì œê°€ ë°œìƒí•œë‹¤.
- **How?**
    - í•´ë‹¹ ì½”ë“œì˜ ë¬¸ì œì— ëŒ€í•´ì„œ Issuesì— ì˜¬ë ¤ ì§ˆë¬¸ì„ í•  ìƒíƒœ
    - https://github.com/qodo-ai/pr-agent/issues/1755
    - https://github.com/qodo-ai/pr-agent/issues/1756
    - ë´‡ì´ ì‘ë‹µì„ í–ˆëŠ”ë° ë¦¬íŒ©í† ë§ í•˜ë©´ ì¢‹ë‹¤ë¼ëŠ” ì‘ë‹µì„ ì–»ìŒ. ë‹´ë‹¹ìë“¤ì—ê²Œ ëª…í™•í•œ ë‹µë³€ì„ ì–»ê³  ì‹¶ì—ˆìœ¼ë‚˜ ë‹´ë‹¹ìë“¤ì˜ ë‹µë³€ì´ ì˜¤ì§€ ì•Šì•„ì„œ ìš°ì„  ì§„í–‰í•´ë³¼ ê²ƒ.

      ![image.png](images/image%202.png)

    - ì½”ë“œ ë¦¬íŒ©í† ë§ ë°©ë²•
        - ë‹¨ì¼ ì±…ì„ ì›ì¹™(SRP)ì— ë”°ë¼ ê¸´ í•¨ìˆ˜ë“¤ì„ ì‘ì€ í•¨ìˆ˜ë¡œ ë¶„í• 
        - ì¤‘ë³µ ë¡œì§ì„ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë¡œ ì¶”ì¶œ
        - ì¤‘ì²© ì¡°ê±´ë¬¸ì„ Early Return íŒ¨í„´ìœ¼ë¡œ ê°œì„ 
        - ë¦¬íŒ©í† ë§ ì´í›„ ìœ ë‹› í…ŒìŠ¤íŠ¸ë¡œ ê¸°ì¡´ ê¸°ëŠ¥ì˜ ì •ìƒ ë™ì‘ ì—¬ë¶€ ê²€ì¦
- **êµ¬í˜„ ê³„íš**
    - **5ì£¼ì°¨**
        - ë¦¬íŒ©í† ë§ì´ í•„ìš”í•œ ì½”ë“œ (ì¤‘ì²©ëœ ì¡°ê±´ë¬¸, ê¸´ í•¨ìˆ˜ ë“±) êµ¬ì²´ì ìœ¼ë¡œ ì„ ì •
            - íŒ€ì› ê°œë³„ ì—­ëŸ‰ì— ë”°ë¼ ì„ íƒ
        - ì„ ì •ëœ ì½”ë“œì— ëŒ€í•œ ì„¸ë¶€ì ì¸ ë¦¬íŒ©í† ë§ ê³„íš ë° ë¬¸ì„œí™”
            - ê¸´ í•¨ìˆ˜ â†’ ë‹¨ì¼ ì±…ì„ì— ë”°ë¼ ë¶„ë¦¬
            - ì¤‘ë³µ ë¡œì§ â†’ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë¡œ ì¶”ì¶œ
            - ì¤‘ì²© ì¡°ê±´ë¬¸ â†’ Early Returnìœ¼ë¡œ ë³€ê²½
        - ìœ„ ì „ëµì— ë”°ë¼ ì´ˆê¸° ë¦¬íŒ©í† ë§ ì‘ì—… ì§„í–‰
    - **6ì£¼ì°¨**
        - ë‚¨ì€ ì½”ë“œì˜ ì¶”ê°€ ë¦¬íŒ©í† ë§ ì§„í–‰
        - ì „ì²´ ë¦¬íŒ©í† ë§ ì½”ë“œì— ëŒ€í•´ ìœ ë‹› í…ŒìŠ¤íŠ¸ë¥¼ í†µí•´ ê¸°ì¡´ ë™ì‘ ìœ ì§€ ê²€ì¦
        - ì½”ë“œ ë¦¬ë·°ë¥¼ ìœ„í•œ PR ì œì¶œ ë° ë™ë£Œ ë¦¬ë·° ì§„í–‰

### ë‹¤ì´ì–´ê·¸ë¨ ìë™ ìƒì„± ê¸°ëŠ¥ ì¶”ê°€

- **What?**
    - PR-Agentì˜ Describe ê¸°ëŠ¥ì—ì„œ ì½”ë“œ ë¦¬ë·° ì‹œ ì‹œí€€ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨, í´ë˜ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨ ë“± ë‹¤ì–‘í•œ ë‹¤ì´ì–´ê·¸ë¨ì„ ìë™ ìƒì„±í•˜ëŠ” ê¸°ëŠ¥ì„ ì¶”ê°€
- **Why?**
    - í˜„ì¬ PR-Agentì˜ DescribeëŠ” í…ìŠ¤íŠ¸ì™€ í‘œë¥¼ ì´ìš©í•´ì„œ ì„¤ëª…ì„ ì œê³µí•œë‹¤.
    - ì´ë¥¼ í†µí•´ì„œë„ ì¶©ë¶„íˆ ì½”ë“œ ì´í•´ê°€ ê°€ëŠ¥í•  ìˆ˜ ìˆìœ¼ë‚˜ ë‹¤ì´ì–´ê·¸ë¨ì„ ì œê³µí•œë‹¤ë©´ ë” ë¹ ë¥´ê³  ì‰¬ìš´ ì´í•´ë¥¼ ë„ìš¸ ê²ƒì´ë¼ê³  íŒë‹¨ì´ ë˜ì—ˆë‹¤.
    - ì½”ë“œ ë¦¬ë·°ì–´ê°€ ì½”ë“œ íë¦„ê³¼ êµ¬ì¡°ë¥¼ ì‹œê°ì ìœ¼ë¡œ ë”ìš± ëª…í™•í•˜ê²Œ ì´í•´í•  ìˆ˜ ìˆë„ë¡ ë•ëŠ”ë‹¤.
- **How?**
    1. Describe ê¸°ëŠ¥ì˜ ì„¤ì •(Configuration)ì— ìƒì„±í•  ë‹¤ì´ì–´ê·¸ë¨ì˜ ì¢…ë¥˜ë¥¼ ì‚¬ìš©ìê°€ ì§€ì •í•  ìˆ˜ ìˆë„ë¡ ì¶”ê°€í•œë‹¤.
    2. Describe í”„ë¡¬í”„íŠ¸ ë‚´ì—ì„œ Jinja í…œí”Œë¦¿ì„ ì´ìš©í•´ ë™ì ìœ¼ë¡œ Mermaid ë‹¤ì´ì–´ê·¸ë¨ ìƒì„± ì§€ì‹œë¥¼ ì¶”ê°€í•˜ì—¬ PR-Agentê°€ ë¶„ì„í•œ ì½”ë“œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì´ë¥¼ ë‹¤ì´ì–´ê·¸ë¨ì´ ìƒì„±í•˜ë„ë¡ í•œë‹¤.
- **êµ¬í˜„ ê³„íš**
    - **5ì£¼ì°¨**
        - PR-Agent ì„¤ì •(Configuration)ì— ë‹¤ì´ì–´ê·¸ë¨ ìƒì„± ì˜µì…˜ ì¶”ê°€ ê¸°ëŠ¥ êµ¬í˜„
        - Jinja í…œí”Œë¦¿ì„ í™œìš©í•œ Mermaid ë‹¤ì´ì–´ê·¸ë¨ ìƒì„±ìš© í”„ë¡¬í”„íŠ¸ ë™ì  ì‚½ì… ê¸°ëŠ¥ êµ¬í˜„
        - Issue ë° Wiki ì •ë³´ë¥¼ ì¶”ê°€ë¡œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆëŠ” ë°©ë²•ì— ëŒ€í•œ ì´ˆê¸° ì¡°ì‚¬ ë° PoC(Proof of Concept) ê°œë°œ
    - **6ì£¼ì°¨**
        - 1ì£¼ì°¨ì— ê°œë°œí•œ ê¸°ëŠ¥ì„ PR-Agentì˜ ê¸°ì¡´ Describe ê¸°ëŠ¥ê³¼ í†µí•© ë° ì—°ë™
        - í†µí•©ëœ ê¸°ëŠ¥ì— ëŒ€í•œ ì¢…í•© í…ŒìŠ¤íŠ¸ ë° ì„±ëŠ¥ ê²€ì¦
        - ë‹¤ì´ì–´ê·¸ë¨ ìƒì„± ì •í™•ì„± ë° í’ˆì§ˆ í–¥ìƒì„ ìœ„í•œ í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§ ë° íŠœë‹
        - ìµœì¢… ê¸°ëŠ¥ì„ PR í˜•íƒœë¡œ ì œì¶œí•˜ê³  ë™ë£Œ ë¦¬ë·° í›„ ìˆ˜ì • ë° ìµœì í™” í›„ ë¨¸ì§€ ì¤€ë¹„